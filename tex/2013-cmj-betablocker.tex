\documentclass[letterpaper, 12pt]{article}


\usepackage{cmjStyle-pdftex} %use CMJ style
\usepackage{natbib} %natbib package, necessary for customized cmj BibTeX style
\bibpunct{(}{)}{;}{a}{}{,} %adapt style of references in text

% \doublespacing


\raggedright % use this to remove spacing and hyphenation oddities
%\setlength{\parindent}{0} % first para indent?
\setlength{\parskip}{2ex}
\parindent 24pt
\urlstyle{same} % make url tags have the same font
\setcounter{secnumdepth}{-1} % remove section numbering

\usepackage{ifpdf}

\DeclareGraphicsExtensions{.pdf,.png,.jpg}
\graphicspath{{../fig/}}


%% The package endfloat moves all floats (figures, tables...) to the end of the paper, as required for the final version of a CMJ paper.
%% Leave this package commented out for initial submission, but uncomment it for final version. 
% \usepackage{endfloat}

%---Document----------
\begin{document}

{\cmjTitle 	Computation as material: (meta) live coding experiences}
\vspace*{24pt}

% (In the initial submission, omit all the following author information to ensure anonymity during peer review.)

%author - name
{\cmjAuthor Till Bovermann}
%author - address
\newline
\begin{cmjAuthorAddress}
	Media Lab Helsinki, Department of Media\\
	Aalto University\\
	H\"ameentie 135 c\\
	00560 Helsinki, Finland\\
	till.bovermann@aalto.fi
\end{cmjAuthorAddress}

\vspace*{24pt}
{\cmjAuthorPhone +358 (50) 5296398}
\vspace*{24pt}

%author - name
{\cmjAuthor Dave Griffiths}
%author - address
\newline
\begin{cmjAuthorAddress}
	Media Lab Helsinki, Department of Media\\
	Aalto University\\
	H\"ameentie 135 c\\
	00560 Helsinki, Finland\\
	dave@fo.am
\end{cmjAuthorAddress}

\vspace*{24pt}
{\cmjAuthorPhone xxxxxxxxxxxxxx}
\vspace*{24pt}


% use of asterisk in section number to remove numbering
\section{Abstract}



\section{<<Start article>>}

% + how people imagine computation now (scary stuff) (Dave)

Computation is odd. 
In fact in many ways it's one of the strangest things that have been discovered, and 77 years on we continue to fail to fully grasp it's behaviour and so, struggle to keep unseen ramifications of our decisions under control. Faced with such a strange and yet essential beast the only sane strategy is to try and tame it. 
The field of software engineering is littered with concepts such as regression testing, type checking, white rooms, sandboxing, contracts, and encapsulation -- all attempts to cope with the fact that we can't really understand how a mundane machine of sufficient complexity will act when it is programmed by a human.

Livecoders look this beast straight in the eyes. 
When a livecoding performer takes to the stage and projects her screen, she invites us to join her in attempting to understand this intricate dance between human and machine. 

But livecoding is more than performance practice.
It is a broad field that can be viewed from many different angles.
From rehearsed public performances, reaching over collaborative improvisations and individual sound explorations, to it's utilisation as a method in science, it has been utilised in a manifold of applications.
All these derivations of the original theme share elements of live coding as they are featured in the toplap manifesto.
So livecoding is attempting to treat computation as a material on it's own terms, pick it up and feel what shapes it has.

Betablocker is an approach to livecoding which has brought to light many different strategies for presenting computation as a tangible material -- and it does this by making this process as much part of the performance as the code that describes it.
Built around this element is a variety of applications for testing, performing and scientific as well as artistic investigations.

Three levels: (a) technology, (b) unfolding as performance/research practice/method (conceptual and descriptive) and (c) aesthetic qualities.


This paper collects experiences, challenges and insights gathered by the two authors over the course of 3 years while investigating the combination of live coding techniques with virtual chips.

Soon after starting the project, it became evident that complex behaviour can emerge out of simple instructions and self-alteration of code.
Leading to a bunch of different insights

\parskip 18pt

\section{BetaBlocker core technology} 
\label{sec:betablocker_core}

% describing the theoretical background and implementation (switch statement etc.)

The Betablocker core is a simple multithreaded virtual machine following the \emph{von Neumann architecture} design pattern where there is no separation between code and data.
It's uncrashable, so every possible program will run, although it will halt in infinite loops. 
It has 23 instructions whose width is either 8 or 16bit for those that take operands. The heap is constrained to 256 bytes of memory, while each thread has 8 bytes of stack. 


BetaBlocker has the following structure:(a) a heap of 256 8bit values, (b) an instruction table, (c) a process consisting of (ca) a program counter, pointing to an address in the heap, and (cb) a stack of eight 8bit values.

\subsection{Heap} 
\label{sub:heap}
This is the place where the program and its data are located. In line to the von Neumann architecture, it is possible (and intended) to alter the program while it is running, i.e. interpreting it as data rather than an instruction set. The actual representation of a heap is an array of 256 8bit values. Each value can be interpreted either as an instruction, an address, or an actual number


\subsection{thread} 
\label{sub:thread}
A thread is something that executes code stored on the heap. It has a current position (the instruction it is currently evaluating), a stack (some sort of storage, see below), and a timer, determining when it will move its program counter to the heap's next address.

\subsection{stack} 
\label{sub:stack}
A stack serves as a temporary storage for a thread. It can be accessed only from top by either (a) pop an item from the stack, (b) return the topmost item without removing it, and (c) push a value to the stack.


\subsection{instructions} 
\label{sub:instructions}

% TODO: IMHO, we should differenciate between a core instruction set (without e.g. NOTE and VOX) and various add-ons (NOTE, VOX, OUT).

These are the implemented instructions:

\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
NOP - do nothing
ORG - define relative origin address for this thread
EQU - compare first two elements on the stack, pop them off the stack, and push the result
JMP - jump to the address specified right after this instruction
JMPZ - jump only if stack returns 0
PSHL - push value on address specified right after this instruction to the stack
PSH - push value on address specified by the value on the address specified right after this instruction to the stack
PSHI - like push but one more encapsulation
POP - pop item from stack to the point in the heap following this instruction
POPI - pop item from stack and write the value at that address in the heap to the address following this instruction
ADD - perform an addition on the first two elements on the stack, pop them off the stack, and push the result
SUB - perform a subtraction on the first two elements on the stack, pop them off the stack, and push the result
INC - increment value on stack
DEC - decrement value on stack
AND - perform a bit-wise "and" on the first two elements on the stack, pop them off the stack, and push the result
OR - perform a bit-wise "or"" on the first two elements on the stack, pop them off the stack, and push the result
XOR - perform a bit-wise "xor" on the first two elements on the stack, pop them off the stack, and push the result
NOT - perform a bit-wise "not" on the first element on the stack, pop it off the stack, and push the result
ROR - perform a right shift operation on the first two elements on the stack, pop them off the stack, and push the result
ROL - perform a left shift operation on the first two elements on the stack, pop them off the stack, and push the result
PIP - increments value specified by the next value on the heap
PIP - decrements value specified by the next value on the heap
DUP - push a duplicate of the topmost value of the stack to the stack
\end{Verbatim}
% NOTE - usually play a note (here: like NOP)
% VOX - usually play a vox (here: like NOP)
% STOP - usually stop program (here: like NOP)

This is their actual implementation:

\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
switch(instr)
{
case NOP: break;
case ORG: m_start=m_start+m_pc-1; m_pc=1; break;
case EQU: push(pop()==pop()); break;
case JMP: m_pc=peek(m,m_pc++); break;
case JMPZ: m_pc++; if (pop()==0) m_pc=peek(m,m_pc); break;
case PSHL: push(peek(m,m_pc++)); break;
case PSH: push(peek(m,peek(m,m_pc++))); break;
case PSHI: push(peek(m,peek(m,peek(m,m_pc++)))); break;
case POP: poke(m,peek(m,m_pc++),pop()); break;
case POPI: poke(m,peek(m,peek(m,m_pc++)),pop()); break;
case ADD: push(pop()+pop()); break;
case SUB: push(pop()-pop()); break;
case INC: push(pop()+1); break;
case DEC: push(pop()-1); break;
case AND: push(pop()&pop()); break;
case OR: push(pop()|pop()); break;
case XOR: push(pop()^pop()); break;
case NOT: push(~pop()); break;
case ROR: push(pop()>>peek(m,m_pc++)); break;
case ROL: push(pop()<<peek(m,m_pc++)); break;
case PIP:
{
u8 d=peek(m,m_pc++);
poke(m,d,peek(m,d)+1);
} break;
case PDP:
{
u8 d=peek(m,m_pc++);
poke(m,d,peek(m,d)-1);
} break;
case DUP: push(top()); break;
case NOTE:
{
// m_pitch=pop();
// m_played_sound=m_pitch;
// m_sound->play(m_instrument,m_pitch);
} break;
case VOX:
{
// m_instrument=pop();
// m_played_sound=m_pitch;
// m_sound->play(m_instrument,m_pitch);
} break;
case STOP: /*m_active=false;*/ break;
default : break;
};
\end{Verbatim}


\section{Background and historical context} 
\label{sec:background}

% musical and computational



\section{Distinct character of Betablocker and its influence on sound and performance practice} 
\label{sec:distinct_character}


% statement: 
The character of Betablocker, be it sonic/computational/musical influences not only the sonic results of a livecoding session but also its overall structuring. 
It is e.g. possible to start with a blank page and speedily add a fairly complicated pattern to it.
In the next subsections, we describe our findings and explorations with regard to Betablocker, as we used it on different levels of (livecoding) performances, and give links on how the mentioned behaviour may influence a livecoding session.

\subsection{Computational features} 
\label{sub:computational_features}

BetaBlocker's distinction to other approaches of computation is manyfold:
(a) Because it is implemented as a software emulation, it can be easily modified, allowing to add e.g. probes or to vary its instruction set.
(b) The formal structure of Betablocker is rather minimal, complexity therefore arises out of the induced data, resp. of the combination of that data and it's processing.
(c) The main purpose of Betablocker is not the outcome of the computation but to be able to observe the process of computation itself. 



% rythmical patterns vs. audiosynthesis
\subsubsection{Slow computing} 
\label{sub:slow_computing}
%  describing the nintendoDS part of the implementation
It began as a highly graphical fluxus based livecoding environment to be performed with the use of a gamepad (debuted at Piksel Festival 200something) and later moved on to the Gameboy DS in order to make use of it's particular graphics processing, sound chip and stylus input method -- while the small screen on the device is projected by the use of a webcam.

% TODO: more detail, also technical level... graphical interface, why you chose the grid gui etc.

Betablocker/Slow (the Fluxus/DS version) makes computation tangible by slowing down processes by many orders of magnitude. 
The smallest musical loop in Betablocker/Slow is 3 instructions long -- push a value onto the stack, play it as a note, jump back to start. 
In order to play this at 120 BPM it will need to run at 6 cycles per second, the machine I am typing on peaks at $2.8*10^9$ cycles per second, which is 466 million times faster than Betablocker/Slow. This makes computation audible as techno music, and simultaneously visible as the thread's positions are displayed on the livecoding interface synced with the audio along with the entire heap's memory contents - forming a complete state vector of the processor.

Performing with Betablocker/Slow consists of starting with empty memory and manually writing programs that modify themselves and each other.
Eventually the quantity of self replicating fork bombs, sequencers interpreting memory as percussion synth triggers and programs busily reversing the contents of memory reaches a level where the performer is confronted with a Turing soup which is happily writing it's own code. 
At this point the decision is whether to collaborate or compete.
Collaboration involves looking for interesting bits of code that emerge and manually modifying them, while the best strategy for competing is attempting to find a space to write a program that gradually clears memory so you can start again. 
In most successful performances both choices are made over the course of the concert.


\subsubsection{Sound computing} 
\label{sub:sound_computing}
%   + SuperCollider (Till)

An alternative way of dealing with the Beatblocker engine is to run it at audio rate and render sound directly.
For easy access of such a method, not only in livecoding settings, we write a SuperCollider UGen implementation for this purpose.\footnote{The implementation is available as open source at \url{https://github.com/supercollider/sc3-plugins}.}
To facilitate typical usage, we decided to provide two different interfaces, a demand-rate UGen (DetaBlockerBuf) allowing to use in SuperCollider's demand chain implementation 
and a multi-out version (BBlockerBuf) that exposes the position of the program counter as well as all 8 elements of the stack.

% playing random instruction sequences vs. "conscious" programming



\subsection{Sonic features} 
\label{sub:sonic_features}

%%%%% on an audiolevel

% synthesis/human creation
%% classic synthesis techniques adapted to Betablocker: e.g. Additive/FM/AM

\begin{figure}
	\centering
		\includegraphics[height=3in]{Additive-Betablocker}
	\caption{Additive synthesis.}
	\label{fig:fig_Additive-Betablocker}
\end{figure}


Additive:
\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
{var output, pC, stack;

var numChains = 5;
var ctls = ['rates'.kr(1000!numChains), 'bufnums'.kr(0!numChains), 'amps'.kr(0.1!numChains)].flop;

output = ctls.collect{|ctl|
  # pC ... stack = BBlockerBuf.ar(
    ctl[0], ctl[1]
  );
  LeakDC.ar(stack[0] * ctl[2]);
};

Out.ar(0, output.sum)}.play;
\end{Verbatim}


\begin{figure}
	\centering
		\includegraphics[height=3in]{FM-Betablocker}
	\caption{Frequency modulation synthesis.}
	\label{fig:fig_FM-Betablocker}
\end{figure}

FM:
\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
{var modulator, pC, stack, carrier;

modulator = Demand.ar(
  Impulse.ar('modRate'.kr(2000)), 
  'reset'.tr(0),
  DetaBlockerBuf('modBufnum'.kr(0))
).linlin(-1, 1, 'modMinAmp'.kr(200), 'modMaxAmp'.kr(1600));

# pC ... stack = BBlockerBuf.ar(
	modulator, 'carBufnum'.kr(0)
);
carrier = LeakDC.ar(stack[0]);

Out.ar(0, carrier)}.play;
\end{Verbatim}


\begin{figure}
	\centering
		\includegraphics[height=3in]{AM-Betablocker}
	\caption{Amplitude modulation synthesis.}
	\label{fig:fig_AM-Betablocker}
\end{figure}

AM:
\begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
{var amp, pC, stack, output;

amp = Demand.ar(
  Impulse.ar('modRate'.kr(2000)), 
  'reset'.tr(0),
  DetaBlockerBuf('modBufnum'.kr(0))
).linlin(-1, 1, 'modMinAmp'.kr(200), 'modMaxAmp'.kr(1600));

# pC ... stack = BBlockerBuf.ar(
  'rate'.kr(1000), 'carBufnum'.kr(0)
);
output = LeakDC.ar(stack[0] * amp);

Out.ar(0, output)}.play;
\end{Verbatim}



%% programming sonic structures: e.g. pulsewave/sawtooth/impulse
%%% excursion: genetic programming with FFT

% analysis/findings
%% sonic variation in random synthesis depends on time: 
%%% first 1000 computation steps could be seen as transiental 
%%% longterm adaption: sound settles over the course of several minutes to be less sharp/rough

The shape of the waveform is limited due to the way the sound signal is derived from the Betablocker engine, namely probing the items on one of its functional parts, the stack. 
However, this limitation is inherent to the structure of the system itself.

Although the system is deterministic, i.e., its outcome can be calculated supposed its state is known, it is so complex that we rather work with empirics than with analytical approaches.

\subsubsection{Noise aesthetics -- on texture and rhythm} 
\label{sub:noise_aesthetics}

%   + limitations and sonic characteristics of betablocker assembler programs

What I found out: Random programs settle into a local stability. there is less high frequencies in the output signal. 

Dynamics in amplitude and pitch can be added by FM/AM-like synth designs.



\subsection{Musical features} 
\label{sub:musical_features}

%%%%% on a rythmical level

% synthesis/human creation
%% programming sonic structures: e.g. drum pattern

\section{Betablocker and livecoding practice: a report} 
\label{sec:betablocker_and_livecoding_practice_a_report}

\subsection{Explicit livecoding vs. meta-livecoding} 
\label{sub:explicit_livecoding_}

% Explicit livecoding (here: on assembler level)
% meta-livecoding (here: the machine codes itself)


\subsection{Unfolding self modification to livecode pseudo-collaboration} 
\label{sec:unfolding_self_modification_to_livecode_collaboration}

Although the output of a given Betablocker stack is deterministic, it still is a mystery (i.e., not determinable) for the human mind - we want them to be like us so we suspend disbelief as a way to gain a tangible understanding

When working mostly with random data input, the pseudo-unpredicability kicks in quite heavily. 

% pseudo-interaction
%% human (behaviour) <---> computer (pseudo-proactive behaviour)

% a turing-test for livecode companions

\subsection{Betablocker livecoding practice}
\label{sub:livecoding_performance_practice_influenced_by_betablocker}

% \subsubsection{Dave's Betablocker practice}
% \label{sub:daves_performance_style}
% 
% 
% \subsubsection{Till's Betablocker practice}
% \label{sub:tills_performance_style}

Subsequent, we describe Betablocker-based performances in their order of appearance.

\subsubsection{SuperCollider symposium London -- livecoding and visuals [4.2012]}
\label{sub:livecoding_and_visuals}

For the livecoding gig at the SuperCollider Symposium 2012, London, the two authors performed together for the first time. 
As they lived at that time already in different countries, they developed a remote rehearsal routine, i.e. each of them prepared his part as a sound recording and the other performed on top of it.

At the same time, both authors prepared their life sets.

Till's aesthetic goal for the performance was to play poly-rhythmical layers of coloured, noisy sounds with a setup purely based around his SuperCollider Betablocker implementation. 
At the same time, he aimed for a certain amount of transparency, i.e., it should be possible to not only see the changes he is making to the code but also how  Betablocker engines alter the heaps' content.
This meant 
(a) to develop a visual representation of the heaps he was playing, 
(b) to design a textual helper environment for his livecoding, mainly providing text blocks, and
(c) to pre-select heaps that he used as "raw materials" for his part of the  performance.

%%% a visual language
different approaches to visual patterning (8bit display, scopes and buffer-iris)


\begin{figure}
	\centering
		\includegraphics[height=3in]{2012-SuperColliderSymposiumLiveCodingEnvironment-till}
	\caption{Till's livecoding environment as used at the SuperCollider symposium 2012, London.}
	\label{fig:fig_2012-SuperColliderSymposiumLiveCodingEnvironment-till}
\end{figure}


\begin{figure}
	\centering
		\includegraphics[width=3in, height=3in]{2013-heapIris-white}
		\includegraphics[width=3in, height=3in]{2013-heapIris-black}
	\caption{Iris-style visualisations of heaps.}
	\label{fig:fig_2013-heapIris-white}
\end{figure}

% \begin{figure}
% 	\centering
% 		\includegraphics[width=2in]{binaryRepresentation-01}
% 		\includegraphics[width=2in]{binaryRepresentation-02}
% 		\includegraphics[width=2in]{binaryRepresentation-03}
% 	\caption{Visual representation of 2x8-bit.}
% 	\label{fig:fig_2013-heapIris-white}
% \end{figure}


\subsubsection{Oulipop -- translation of codes [5.2012]}
\label{sub:oulipop}
2 Performers, 1 laptop, 20 minutes. Till Bovermann and Sara Hildebrand Marques Lopes.

%%% translation of codes: Oulipop
Relation between written text, code and sound.

Manipulating texts according to Oulipo rules (\cite{mathews2005-oul}).
Meta-level live-coding. 
Each keystroke triggers a process that translates the current text's characters into a set of commands for a fictional CPU. 
Treated as a sound signal, the ever-changing output of that CPU is played back, and thereby influences the performers' decisions on how to further alter the text. 
Over the course of the performance, an initially meaningful text turns into nonsense before it eventually settles into a new and often surprising semantical meaning.\footnote{For more information and a documentation video, see \url{http://www.tai-studio.org/oulipop/}.}
\begin{figure}
	\centering
		\includegraphics[height=3in]{20120509-IMG_3278}
	\caption{The Oulipop performance environment.}
	\label{fig:fig_20120509-IMG_3278}
\end{figure}


%%% Research in computing processes
Based on phenomenological methods/maxims, treating the subject of investigation (here: BetaBlocker) as being only perceivable \emph{through} phenomena (things "present to the mind"). 
As we are interested in sonic qualities, the selected modality of the observed phenomena are mainly of sonic nature.
On our way through the system, though, other introspective as well as extrospective data emerged and was taken into account.

To illustrate the research journey, we will now list key events that happened:

Starting point was a collection of C files that defined the BetaBlocker core.
To keep things simple at the beginning, a crucial strategy in implementations, we decided to fill the heap with a very simple program resembling a sawtooth \verb#[ORG, INC, JMP, 0]#. 
After successfully listening to this basic setup, we replaced the hardcoded heap with one that gets initialised with random values between $0$ and $255$.\footnote{\url{http://tai-studio.org/index.php/2011/05/betablocker-ugen/}}

% listening experience
Airy, sustained sound clouds; mostly high-pitched broken up occasionally by a rhythmical pattern
% listening experience end

\begin{itemize}	 
\item Implemented access to heap's data. This means that it can be set, read and manipulated while running. Also, several engines can share a heap. 
	% http://tai-studio.org/index.php/2011/08/detablockerbuf-8channel/ 
\item helper classes facilitating the generation of BBlocker programs 
	% http://tai-studio.org/index.php/2011/08/twentydblockers/ 
\item further sonic exploration, listening sessions 
	% http://tai-studio.org/index.php/2011/10/betablocker-pieces/

	For now, the layout is always additive, i.e., several BBlocker engines next to each other

\item Idea generation
	% http://tai-studio.org/index.php/2011/10/betablocker-theory-day/ 
\item Visual representation
	% http://tai-studio.org/index.php/2011/11/attempt-for-representing-2x8bit/
\item public demo video
	% http://tai-studio.org/index.php/2011/12/dblockerintro/ 
\item adding convenience methods play/scope/plot to BBlockerProgram based on feedback of first introduction to a non-programmer
	% http://tai-studio.org/index.php/2011/12/cambridge-day-4/ 
\item New iteration of the BetaBlocker wrapper, adding more output (pos and whole stack) and removing the possibility to control it with demand rate,
	% http://tai-studio.org/index.php/2011/12/60-panned/ 
	includes a sound study.
\item Multi-out UGen with audio-rate input
	% http://tai-studio.org/index.php/2011/12/cambridge-day-8/
\item Decision to focus on sonic aspects. Therefore tried to write/design programs with specific sonic features in mind.
	% http://tai-studio.org/index.php/2011/12/cambridge-days-912/
\item FM-like synthesis strategy added
\item Performance at Cambridge, fixed setup
\item Rehearsal for SuperCollider Symposium
\item Concert at SuperCollider Symposium
\item Workshop at UdK.
\item Oulipop performance
\end{itemize}



\section{Meta}
\label{sec:meta}


\begin{figure}
	\centering
		\includegraphics[height=3in]{../fig/bbds-seq.png}
	\caption{caption}
	\label{fig:fig_bbds-seq}
\end{figure}


\begin{figure}
	\centering
		\includegraphics[height=3in]{../fig/bbbot.JPG}
	\caption{caption}
	\label{fig:fig_bbbot}
\end{figure}





\vspace*{24pt}





\vspace*{24pt}


% % format for Heading-B style
% \subsection{Format for Heading-B Style; Use This for Subsection Headings}
% 
% Insert body text here.  
% 
% % format for Heading-C style
% \subsubsection{Format for Heading-C Style; Use This for Minor Sub-subsection Headings}
% 
% Insert body text here.
% 
% In the initial manuscript submission, you are encouraged to include figures (with captions) inline with the text, for ease of reading during the review process. For example, like this:
% 
% % include figures in text with captions for initial submission, like this:
% \begin{figure}[htpb]
% \begin{center}
% \includegraphics{myFigure.pdf}
% \caption{Insert Figure caption here.}
% \label{fig:myFigure}
% \end{center}
% \end{figure}
% 
% However, for the final version after the manuscript has been accepted, all figures should be moved to the end so that the text only contain markers like ``[Figure 1 about here]'' near where the figure would normally have occurred. You can rearrange the text to this effect simply by enabling the package {\tt endfloat} as suggested in the header of this document.
% 
% 
% % equations
% You can insert equations inline with the text like this:
% 
% \begin{equation}
% 	\label{radupdate}
% 		\Psi_{N}^{n+1} = m_{N}^{(-)}\Psi_{N-1}^{n}+m_{N}^{(0)}\Psi_{N}^{n} + q_{N}\Psi_{N}^{n-1}
% \end{equation}
% where
% \begin{eqnarray*}
% 	m_{N}^{(-)} &=& \frac{\lambda^2}{2\tau}\left(S_{N+1}+2S_{N}+S_{N-1}\right)\\
% 	m_{N}^{(0)} &=& \frac{1}{\tau}\left(2-\frac{\lambda^2}{2}\left(S_{N+1}+2S_{N}+S_{N-1}\right)\right)\\
% 	q_{N} &=& \frac{1}{\tau}\left(\frac{\gamma^2 k^2}{2h}\left(S_{N+1}+S_{N}\right)\left(\frac{\alpha_{1}}{k}-	\alpha_{2}\right)-1\right)
% \end{eqnarray*}
% and where 
% \begin{equation*}
% 	\tau = \frac{\gamma^2 k^2}{2h}\left(S_{N+1}+S_{N}\right)\left(\frac{\alpha_{1}}{k}+\alpha_{2}\right)+1
% \end{equation*}
% 
% % Use this environment for inserting source code examples.
% % Note, that this will print out text in the document exactly as you type it here in the .tex file. That means you can add empty spaces, tabs, blank lines here and they will be printed out like this in the document.). 
% %For more information check out the LaTeX-Package 'fancyvbr' documentation
% %
% \begin{Verbatim}[fontfamily=courier, xleftmargin=\parindent]
% Use this style for program code, for example:
% main() {
%     printf("Hello World\n");    
% }
% \end{Verbatim}
% 
% %use of references
% Some examples for the use of references in the text:\\
% %author name in sentence, single authors
% \cite{Ano08}, \cite{Bele68}, \cite{Ther99}, \cite{Zica02},
% %author name in sentence, multiple authors
% \cite*{VeRo00}, \cite*{AtDa04}, 
% %reference in brackets, multiple authors
% \citep*{AtDa04} 


%References
\bibliographystyle{cmj}
% \bibliography{cmjbib}
\bibliography{/Users/tboverma/Public/unpub/BibTeX/bovermann}
\end{document}
